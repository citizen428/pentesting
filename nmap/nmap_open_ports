#!/usr/bin/env ruby
# Original author : FreedomCoder (Matias Pablo Brutti)
# Email: matiasbrutti ---- gmail ---- com
# Created on : February 9, 2009
#
# Updated by: Michael Kohl <citizen428 ---- gmail ---- com>
# Updated on: October 28, 2011
# Changes:
#   - make it work with 1.8 and 1.9
#   - make --dir and --file mutually exclusive
#   - catch if user tries to generate PDF and prawn is not installed
#   - option parsing improvements
#   - add non-zero exit codes on error
#   - replace instance variables with options hash
#   - Ruby code/style fixes
#   - add verbose option
#   - modified wording
#   - remove PDF table formatting
#   - better output formatting for show_data
# Description : Output parser for nmap that creates a table of port-ip
# mappings.

require 'rubygems'
require 'getoptlong'
require 'rexml/document'

options = {}

opts = GetoptLong.new(
                      [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
                      ['--dir', '-d', GetoptLong::REQUIRED_ARGUMENT ],
                      ['--file', '-f', GetoptLong::REQUIRED_ARGUMENT ],
                      ['--pattern', '-p', GetoptLong::REQUIRED_ARGUMENT ],
                      ['--output', '-o', GetoptLong::REQUIRED_ARGUMENT ],
                      ['--type', '-t', GetoptLong::REQUIRED_ARGUMENT ],
                      ['--verbose', '-v', GetoptLong::NO_ARGUMENT ])

opts.each do |opt, arg|
  case opt
  when '--help' then
    puts <<HELP
#{File.basename($0)}

--help, -h
\tThis help.
--dir, -d [directory_name]
\tRoot path for nmap files.
--pattern, -p
\tFile pattern for nmap files (i.e *client*).
--file, -f [file_name]
\tSpecify a single nmal XML file.
--output, -o
\tOutput file name.
--verbose, -v
\tDisplay extra info while generating report.
HELP
    exit 0
  when '--dir' then
    if File.directory?(arg)
      options[:nmap_dir] = arg
    else
      puts "Directory not found or file is not a directory"
      exit 1
    end
  when '--file' then
    if File.exists?(arg) && !options[:nmap_dir]
      options[:nmap_file] = arg
    else
      puts "File not found or you specified both --dir and --file"
      exit 1
    end
  when '--pattern' then
    options[:pattern] = arg
  when '--output' then
    options[:output] = arg
    options[:type] ||= options[:output].split(".").last.upcase
  when '--type' then
    if arg =~ /pdf|csv/i
      options[:type] = arg.upcase
    else
      puts "Unrecognized file type"
      exit 1
    end
  when '--verbose' then
    options[:verbose] = true
  else
    puts "Unknown command"
    exit 1
  end
end

# we need either a directory or an nmap file
unless options[:nmap_dir] || options[:nmap_file]
  puts "You need to specify either --dir or --file"
  exit 1
end

# catch Prawn errors
if options[:type] == 'PDF'
  begin
    require 'prawn'
    require 'prawn/layout'
  rescue LoadError
    puts "To generate PDFs, please install the Prawn gem"
    exit 2
  end
end

# methods to read files from directory

def get_files(dir, name)
  Dir["#{dir}/**/#{name || "*.xml"}"]
end

def dir_open_ports(dir)
  dir.inject([]) do |arr, doc|
    arr << open_ports(read_xml(doc))
  end.flatten.uniq.sort
end

def dir_get_ips(dir, ports)
  final_list = {}
  dir.each do |doc|
    puts "Working on #{doc}"
    final_list.merge!(get_ips(read_xml(doc), ports)) { |k, o, n| final_list[k] = (o | n).sort }
  end
  final_list
end

# methods to parse XML nmap output

def read_xml(xml)
  REXML::Document.new(File.read(xml)).root
end

def open_ports(doc)
  out = []
  doc.elements.each('host') do |h|
    h.elements.each('ports/port') do |p|
      if p.elements['state'].attributes['state'] == "open"
        out << "#{p.attributes['portid']}/#{p.attributes['protocol']}"
      end
    end
  end
  out.uniq.sort
end

def open?(host,port)
  host.elements.each('ports/port') do |p|
    if p.attributes['portid'] == port.split("/").first && p.elements['state'].attributes['state'] == "open"
      return true
    end
  end
  false
end

def get_ips(doc, ports)
  open_list = {}
  ports.each do |port|
    a = []
    doc.elements.each('host') do |h|
      a << h.elements['address'].attributes['addr'] if open?(h, port)
    end
    open_list[port] = a
  end
  open_list
end

# data output
def create_output(list, options)
  case options[:type]
  when "PDF" then
    create_pdf(list, options[:output])
    puts "Data written to file #{options[:output] || "output.pdf"}" if options[:verbose]
  when "CSV" then
    create_csv(list, options[:output])
    puts "Data written to file #{options[:output] || "output.csv"}" if options[:verbose]
  else
    puts "No output format specified, using CSV" if options[:verbose]
    create_csv(list, options[:output])
    puts "Data written to file #{options[:output] || "output.csv"}" if options[:verbose]
  end
end

def create_csv(list, name=nil)
  File.open(name || "output.csv", "w") do |f|
    f.puts "Port;IP Adressess"
    list.each do |k,v|
      f.puts "#{k};#{v.join(',')}"
    end
  end
end

def create_pdf(list, name=nil)
  Prawn::Document.generate(name || "output.pdf") do
    data = [["Port","IP Addresses"]]
    list.each do |k, v|
      data << [k, v.join(',')]
    end

    table(data, :header => true)
  end
end

def show_data(list)
  puts "%-10s %s" % ["Port", "IP Adressess"]
  list.each do |k, v|
    puts "%-10s %s" % [k, v.join(',')]
  end
end

# main script
puts "Generating report" if options[:verbose]
list = {}

if options[:nmap_dir]
  dir_list = get_files(options[:nmap_dir], options[:pattern])
  ports = dir_open_ports(dir_list)
  list = dir_get_ips(dir_list, ports)
elsif options[:nmap_file]
  xml_file = read_xml(options[:nmap_file])
  ports = open_ports(xml_file)
  list = get_ips(xml_file, ports)
end

show_data(list) if options[:verbose]
create_output(list, options)
